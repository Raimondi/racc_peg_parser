# vim:set ft=ruby:
class Peg::Parser

rule

# #Original PEG PEG grammar.
## Hierarchical syntax
#
#Grammar <- Spacing Definition+ EndOfFile
#Definition <- Identifier LEFTARROW Expression
#
#Expression <- Sequence (SLASH Sequence)*
#Sequence <- Prefix*
#
#Prefix <- (AND / NOT)? Suffix
#
#Suffix <- Primary (QUESTION / STAR / PLUS)?
#Primary <- Identifier !LEFTARROW
#/ OPEN Expression CLOSE / Literal / Class / DOT
## Lexical syntax
#
#Identifier <- IdentStart IdentCont* Spacing
#IdentStart <- [a-zA-Z_]
#
#IdentCont <- IdentStart / [0-9]
#
#Literal <- ['] (!['] Char)* ['] Spacing / ["] (!["] Char)* ["] Spacing
#
#Class <- '[' (!']' Range)* ']' Spacing
#Range <- Char '-' Char / Char
#
#Char <- '\\' [nrt'"\[\]\\]
#/ '\\' [0-2][0-7][0-7] / '\\' [0-7][0-7]?
#/ !'\\' .
#
#LEFTARROW <- '<-' Spacing
#SLASH <- '/' Spacing
#AND <- '&' Spacing
#NOT <- '!' Spacing
#QUESTION <- '?' Spacing
#STAR <- '*' Spacing
#PLUS <- '+' Spacing
#OPEN <- '(' Spacing
#CLOSE <- ')' Spacing
#DOT <- '.' Spacing
#
#Spacing <- (Space / Comment)*
#
#Comment <- '#' (!EndOfLine .)* EndOfLine
#Space <- ' ' / '\t' / EndOfLine
#EndOfLine <- '\r\n' / '\n' / '\r'
#EndOfFile <- !.

grammar : definition END

definition : identifier leftarrow expression
           | definition identifier leftarrow expression

expression : sequence alternative

alternative : # Empty
            | alternative slash sequence

sequence : # Empty
         |  suffix
         |  and suffix
         |  not suffix

suffix : primary quantifier

quantifier : # Empty
           | question
           | star
           | plus

primary : identifier
        | open expression close
        | literal
        | CLASS
        | dot
# lexical syntax

identifier : IDENTSTART identcont

identcont : # Empty
          | identcont identstart
          | identcont NUMBER

literal : SQSTRING
        | DQSTRING

#literal : SQUOTE chars SQUOTE
#        | DQUOTE chars DQUOTE
#chars : # Empty
#      | chars char
#
#class : OPEN_SQ range CLOSE_SQ
#range : # Empty
#      | range char DASH char
#      | range char
#
#char : ESC
#     | OCT
#     | NON_ESC

leftarrow : ARROW
slash : SL
and : AMPER
not : EXCLAMATION
question : INTERR
star : STAR
plus : PLUS
open : OPEN_PAREN
close : CLOSE_PAREN
dot : POINT

end

---- inner ----
  @yydebug=true
  def parse(tokens)
    @yydebug = true
    @tokens = tokens
    do_parse
  end

  #def on_error( *args )
  #  $stderr.puts "on_error called: args=#{args.inspect}"
  #end

  def next_token
    token = @tokens.shift
    puts "Token: #{token.inspect}"
    token
  end

